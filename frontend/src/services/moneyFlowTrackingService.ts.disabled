// moneyFlowTrackingService.ts - Service that tracks money flow from contracts to budget execution
import { 
  getContractData, 
  getMultiYearFinancialData,
  ContractData,
  YearlyData
} from './financialDataService';

// Interfaces for money flow tracking
export interface MoneyFlowEntry {
  year: number;
  contractId: string;
  contractTitle: string;
  contractAmount: number;
  budgetCategory: string;
  budgetedAmount: number;
  executedAmount: number;
  executionRate: number;
  variance: number;
  potentialDiversion: boolean;
  notes: string;
}

export interface YearlyMoneyFlowSummary {
  year: number;
  totalContracts: number;
  totalContractValue: number;
  totalBudgeted: number;
  totalExecuted: number;
  executionRate: number;
  infraBudgeted: number;
  infraExecuted: number;
  personnelBudgeted: number;
  personnelExecuted: number;
  infraExecutionRate: number;
  personnelExecutionRate: number;
  potentialDiversion: boolean;
  diversionNotes: string;
}

export interface MoneyFlowAnalysis {
  entries: MoneyFlowEntry[];
  yearlySummaries: YearlyMoneyFlowSummary[];
  overallSummary: {
    totalYears: number;
    totalContracts: number;
    totalContractValue: number;
    avgExecutionRate: number;
    yearsWithDiversion: number;
    diversionPercentage: number;
  };
}

class MoneyFlowTrackingService {
  private static instance: MoneyFlowTrackingService;
  private cache = new Map<string, { data: any; timestamp: number }>();
  private readonly CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

  private constructor() {}

  public static getInstance(): MoneyFlowTrackingService {
    if (!MoneyFlowTrackingService.instance) {
      MoneyFlowTrackingService.instance = new MoneyFlowTrackingService();
    }
    return MoneyFlowTrackingService.instance;
  }

  /**
   * Track money flow from contracts to budget execution
   */
  public async trackMoneyFlow(): Promise<MoneyFlowAnalysis> {
    const cacheKey = 'money-flow-analysis';
    const cached = this.cache.get(cacheKey);

    if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
      return cached.data;
    }

    try {
      // Load all required data
      const [contracts, financialData] = await Promise.all([
        getContractData(),
        getMultiYearFinancialData()
      ]);

      // Create money flow entries
      const entries: MoneyFlowEntry[] = [];
      
      // For each contract, find corresponding budget execution data
      contracts.forEach(contract => {
        const yearData = financialData.find(d => d.year === contract.year);
        
        if (yearData) {
          // Match contract to budget category
          let budgetCategory = '';
          let budgetedAmount = 0;
          let executedAmount = 0;
          
          switch (contract.category) {
            case 'infra':
              budgetCategory = 'Infraestructura';
              budgetedAmount = yearData.planned_infra;
              executedAmount = yearData.executed_infra;
              break;
            case 'services':
            case 'personnel':
              budgetCategory = 'Personal';
              budgetedAmount = yearData.personnel;
              executedAmount = yearData.personnel;
              break;
            default:
              budgetCategory = 'Otros';
              budgetedAmount = yearData.total_budget * 0.1; // 10% estimation
              executedAmount = yearData.total_executed * 0.1; // 10% estimation
          }
          
          const executionRate = budgetedAmount ? (executedAmount / budgetedAmount) * 100 : 0;
          const variance = contract.amount - executedAmount;
          const potentialDiversion = executionRate < 80; // Flag if execution rate is below 80%
          
          entries.push({
            year: contract.year,
            contractId: contract.id,
            contractTitle: contract.title,
            contractAmount: contract.amount,
            budgetCategory,
            budgetedAmount,
            executedAmount,
            executionRate: parseFloat(executionRate.toFixed(1)),
            variance,
            potentialDiversion,
            notes: potentialDiversion ? 'Ejecución baja - posible desvío' : 'Ejecución adecuada'
          });
        }
      });

      // Create yearly summaries
      const yearlySummaries: YearlyMoneyFlowSummary[] = financialData.map(yearData => {
        const yearContracts = contracts.filter(c => c.year === yearData.year);
        const totalContractValue = yearContracts.reduce((sum, c) => sum + c.amount, 0);
        
        const infraExecutionRate = yearData.planned_infra ? (yearData.executed_infra / yearData.planned_infra) * 100 : 0;
        const personnelExecutionRate = (yearData.total_budget * 0.45) ? 
          (yearData.personnel / (yearData.total_budget * 0.45)) * 100 : 0;
        
        // Check for potential diversions (>45% personnel spending is often a concern)
        const potentialDiversion = (yearData.personnel / (yearData.total_executed || 1)) > 0.45;
        
        return {
          year: yearData.year,
          totalContracts: yearContracts.length,
          totalContractValue,
          totalBudgeted: yearData.total_budget,
          totalExecuted: yearData.total_executed,
          executionRate: yearData.total_budget ? parseFloat(((yearData.total_executed / yearData.total_budget) * 100).toFixed(1)) : 0,
          infraBudgeted: yearData.planned_infra,
          infraExecuted: yearData.executed_infra,
          personnelBudgeted: Math.round(yearData.total_budget * 0.45),
          personnelExecuted: yearData.personnel,
          infraExecutionRate: parseFloat(infraExecutionRate.toFixed(1)),
          personnelExecutionRate: parseFloat(personnelExecutionRate.toFixed(1)),
          potentialDiversion,
          diversionNotes: potentialDiversion ? 
            `Gastos de personal altos (${((yearData.personnel / (yearData.total_executed || 1)) * 100).toFixed(1)}%)` : 
            'Sin desvíos significativos'
        };
      });

      // Create overall summary
      const overallSummary = {
        totalYears: financialData.length,
        totalContracts: contracts.length,
        totalContractValue: contracts.reduce((sum, c) => sum + c.amount, 0),
        avgExecutionRate: parseFloat((yearlySummaries.reduce((sum, y) => sum + y.executionRate, 0) / (yearlySummaries.length || 1)).toFixed(1)),
        yearsWithDiversion: yearlySummaries.filter(y => y.potentialDiversion).length,
        diversionPercentage: parseFloat(((yearlySummaries.filter(y => y.potentialDiversion).length / (yearlySummaries.length || 1)) * 100).toFixed(1))
      };

      const moneyFlowAnalysis: MoneyFlowAnalysis = {
        entries,
        yearlySummaries,
        overallSummary
      };

      this.cache.set(cacheKey, { data: moneyFlowAnalysis, timestamp: Date.now() });
      return moneyFlowAnalysis;
    } catch (error) {
      console.error('Error tracking money flow:', error);
      throw error;
    }
  }

  /**
   * Get potential diversions
   */
  public async getPotentialDiversions(): Promise<YearlyMoneyFlowSummary[]> {
    const analysis = await this.trackMoneyFlow();
    return analysis.yearlySummaries.filter(summary => summary.potentialDiversion);
  }

  /**
   * Get money flow data for a specific year
   */
  public async getMoneyFlowForYear(year: number): Promise<MoneyFlowAnalysis> {
    const analysis = await this.trackMoneyFlow();
    
    return {
      entries: analysis.entries.filter(entry => entry.year === year),
      yearlySummaries: analysis.yearlySummaries.filter(summary => summary.year === year),
      overallSummary: {
        totalYears: 1,
        totalContracts: analysis.entries.filter(entry => entry.year === year).length,
        totalContractValue: analysis.entries
          .filter(entry => entry.year === year)
          .reduce((sum, entry) => sum + entry.contractAmount, 0),
        avgExecutionRate: parseFloat((
          analysis.yearlySummaries
            .filter(summary => summary.year === year)
            .reduce((sum, summary) => sum + summary.executionRate, 0) / 
          (analysis.yearlySummaries.filter(summary => summary.year === year).length || 1)
        ).toFixed(1)),
        yearsWithDiversion: analysis.yearlySummaries.filter(y => y.year === year && y.potentialDiversion).length,
        diversionPercentage: analysis.yearlySummaries.filter(y => y.year === year && y.potentialDiversion).length > 0 ? 100 : 0
      }
    };
  }

  /**
   * Clear cache
   */
  public clearCache(): void {
    this.cache.clear();
  }
}

// Export singleton instance
export const moneyFlowTrackingService = MoneyFlowTrackingService.getInstance();
export default moneyFlowTrackingService;